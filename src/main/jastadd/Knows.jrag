aspect Knows {
  inh String Expr    .lookupKnows();
  inh String Stmt    .lookupKnows();
  inh String BodyDecl.lookupKnows();
  inh String TypeDecl.lookupKnows();

  eq KnowsClassDecl.getBodyDecl().lookupKnows() = getKnows().getLITERAL();
  eq Program       .getChild   ().lookupKnows() = null;


  DlQueryExpr contributes error("class 'knows' no data source for querying")
    when lookupKnows() == null
    to CompilationUnit.problems();

  DlTypecaseStmt contributes error("class 'knows' no data source for typecasing")
    when lookupKnows() == null
    to CompilationUnit.problems();

  SemanticTypeAccess contributes error("class 'knows' no data source for semantic type")
    when lookupKnows() == null
    to CompilationUnit.problems();
}


aspect KnowsBackend {
  inh KnowsClassDecl Expr    .getKnowBase();
  inh KnowsClassDecl Stmt    .getKnowBase();
  inh KnowsClassDecl BodyDecl.getKnowBase();
  inh KnowsClassDecl TypeDecl.getKnowBase();

  eq KnowsClassDecl.getBodyDecl().getKnowBase() = this;
  eq Program       .getChild   ().getKnowBase() = null;


  public Dot KnowsClassDecl.mkAccess() {
    return new Dot(
      lookupType("semantics", "KnowBase").createQualifiedAccess(),
      new MethodAccess("of", new List<Expr>(new StringLiteral(getKnows().getLITERAL())))
    );
  }


  public Dot KnowsClassDecl.mkMethodAccess(String id, Expr... args) {
    List<Expr> argList = new List<>();

    for (Expr arg : args) {
      argList.add(arg);
    }

    return new Dot(mkAccess(), new MethodAccess(id, argList));
  }
}
