aspect Projection {
  syn TypeDecl DlProjectionish.getProjectionType(Roleish r) {
    TypeDecl   et = getExpr().type();
    Conceptual c;

    if (et.isSemanticTypeDecl()) {
      c = ((SemanticTypeDecl) et).getConcept();
    }
    else {
      c = new Top();
    }

    Collection<TypeDecl> param = new LinkedList<>();
    String               path  = lookupKnows();

    if (path != null) {
      ClassDecl  ind    = (ClassDecl) lookupType("semantics.model", "Individual");
      Conceptual exists = new Existence(new Inversion(r), c).stripUnknownConcept();
      param.add(ind.semanticTypeDecl(path, exists));
    }
    else {
      param.add(unknownType());
    }

    GenericInterfaceDecl set = (GenericInterfaceDecl) lookupType("java.util", "Set");
    return set.lookupParTypeDecl(param);
  }

  eq DlProjectionExpr       .type() = getProjectionType(getRole().toModel());
  eq DlDynamicProjectionExpr.type() = getProjectionType(getRoleExpr().toRoleish());


  protected boolean DlProjectionish.isIndividual(Expr e) {
    return e.type().instanceOf(lookupType("semantics.model", "Individual"));
  }

  protected Problem DlProjectionish.errorNotIndividual(Expr e) {
    return errorf("'%s' is not an individual", e.type().typeName());
  }

  DlProjectionish contributes errorNotIndividual(getExpr())
    when !isIndividual(getExpr())
    to CompilationUnit.problems();

  DlDynamicProjectionExpr contributes errorNotRoleOrString(getRoleExpr())
    when !isRoleOrString(getRoleExpr())
    to CompilationUnit.problems();


  DlDynamicProjectionExpr contributes signatureWarning(getRoleExpr().toRoleish())
    when !hasSignature(getRoleExpr().toRoleish(), "role")
    to CompilationUnit.problems();
}


aspect ProjectionBackend {
  syn Expr DlProjectionish.getProjectExpr();

  eq DlProjectionExpr       .getProjectExpr() = getRole().toExpr();
  eq DlDynamicProjectionExpr.getProjectExpr() = mkModel("Role", getRoleExpr());


  syn nta Expr DlProjectionish.getTransformed() =
    getKnowBase().mkMethodAccess(
        "project", getExpr().treeCopyNoTransform(), getProjectExpr());

  public void DlProjectionish.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
