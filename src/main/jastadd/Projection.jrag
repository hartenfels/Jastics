aspect Projection {
  syn Conceptual DlProjectionExpr.getExprConcept() {
    TypeDecl et = getExpr().type();
    return et.isSemanticTypeDecl()
         ? ((SemanticTypeDecl) et).getConcept()
         : new Everything();
  }

  protected Conceptual DlProjectionExpr.getResultingConcept(Roleish r, Conceptual c) {
    return new Existence(new Inversion(r), c).stripUnknown();
  }


  eq DlProjectionExpr.type() {
    Roleish    r  = getRoleExpr().toRoleish();
    Conceptual c  = getExprConcept();

    Collection<TypeDecl> param = new LinkedList<>();
    String               path  = lookupDataSource();

    if (path != null) {
      ClassDecl ind = (ClassDecl) lookupType("semantics.model", "Individual");
      param.add(ind.semanticTypeDecl(path, getResultingConcept(r, c)));
    }
    else {
      param.add(unknownType());
    }

    GenericInterfaceDecl set = (GenericInterfaceDecl) lookupType("java.util", "Set");
    return set.lookupParTypeDecl(param);
  }


  protected boolean DlProjectionExpr.isIndividual(Expr e) {
    return e.type().instanceOf(lookupType("semantics.model", "Individual"));
  }

  protected Problem DlProjectionExpr.errorNotIndividual(Expr e) {
    return errorf("'%s' is not an individual", e.type().typeName());
  }

  DlProjectionExpr contributes errorNotIndividual(getExpr())
    when !isIndividual(getExpr())
    to CompilationUnit.problems();

  DlProjectionExpr contributes errorNotRoleable(getRoleExpr())
    when !isRoleable(getRoleExpr())
    to CompilationUnit.problems();


  syn lazy boolean DlProjectionExpr.isGuaranteedUnsatisfiable() {
    String     path = lookupDataSource();
    Roleish    r  = getRoleExpr().toRoleish();
    Conceptual c  = getExprConcept();
    return path != null && c != null && !c.isUnknown()
        && !KnowBase.of(path).isSatisfiable(getResultingConcept(r, c));
  }

  DlProjectionExpr contributes
      errorf("projection of %s on %s is unsatisfiable",
             getRoleExpr().toRoleish(), getExprConcept())
    when isGuaranteedUnsatisfiable()
    to CompilationUnit.problems();


  DlProjectionExpr contributes signatureWarning(getRoleExpr().toRoleish())
    when !hasSignature(getRoleExpr().toRoleish(), "role")
    to CompilationUnit.problems();
}


aspect ProjectionBackend {
  syn nta Expr DlProjectionExpr.getTransformed() =
    getKnowBase().mkMethodAccess(
        "project", getExpr().treeCopyNoTransform(), mkModel("Role", getRoleExpr()));

  public void DlProjectionExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
