aspect Query {
  eq DlEverythingExpr  .type() = lookupType("semantics.model", "Everything");
  eq DlNothingExpr     .type() = lookupType("semantics.model", "Nothing");
  eq DlUnionExpr       .type() = lookupType("semantics.model", "Union");
  eq DlIntersectionExpr.type() = lookupType("semantics.model", "Intersection");
  eq DlExistenceExpr   .type() = lookupType("semantics.model", "Existence");
  eq DlUniversalExpr   .type() = lookupType("semantics.model", "Universal");
  eq DlNegationExpr    .type() = lookupType("semantics.model", "Negation");
  eq DlInversionExpr   .type() = lookupType("semantics.model", "Inversion");
  eq DlOneExpr         .type() = lookupType("semantics.model", "One");

  eq DlQueryExpr.type() = lookupType("semantics", "Individuals");


  protected boolean Expr.isConceptOrString(Expr e) {
    TypeDecl conceptual = lookupType("semantics.model", "Conceptual");
    TypeDecl td         = e.type();
    return td.isString() || td.instanceOf(conceptual);
  }

  protected boolean Expr.isRoleOrString(Expr e) {
    TypeDecl roleish = lookupType("semantics.model", "Roleish");
    TypeDecl td      = e.type();
    return td.isString() || td.instanceOf(roleish);
  }

  protected Problem Expr.errorNotConceptOrString(Expr e) {
    return errorf("'%s' is neither concept nor string", e.type().typeName());
  }

  protected Problem Expr.errorNotRoleOrString(Expr e) {
    return errorf("'%s' is neither role nor string", e.type().typeName());
  }


  DlBinaryExpr contributes errorNotConceptOrString(getLeftOperand())
    when !isConceptOrString(getLeftOperand())
    to CompilationUnit.problems();

  DlBinaryExpr contributes errorNotConceptOrString(getRightOperand())
    when !isConceptOrString(getRightOperand())
    to CompilationUnit.problems();

  DlQuantifierExpr contributes errorNotRoleOrString(getLeftOperand())
    when !isRoleOrString(getLeftOperand())
    to CompilationUnit.problems();

  DlQuantifierExpr contributes errorNotConceptOrString(getRightOperand())
    when !isConceptOrString(getRightOperand())
    to CompilationUnit.problems();

  DlNegationExpr contributes errorNotConceptOrString(getOperand())
    when !isConceptOrString(getOperand())
    to CompilationUnit.problems();

  DlInversionExpr contributes errorNotRoleOrString(getOperand())
    when !isRoleOrString(getOperand())
    to CompilationUnit.problems();

  DlOneExpr contributes errorf("'%s' is not a string", getOperand().type().typeName())
    when !getOperand().type().isString()
    to CompilationUnit.problems();

  DlQueryExpr contributes errorNotConceptOrString(getOperand())
    when !isConceptOrString(getOperand())
    to CompilationUnit.problems();
}


aspect QueryBackend {
  protected Expr Expr.wrapStringInConcept(Expr e) {
    if (e.type().isString()) {
      return new ClassInstanceExpr(
        lookupType("semantics.model", "Concept").createQualifiedAccess(),
        new List<Expr>(e.treeCopyNoTransform())
      );
    }
    else {
      return e.treeCopyNoTransform();
    }
  }

  protected Expr Expr.adoptToParent(Expr e) {
    e.setParent(getParent());
    return e;
  }


  protected abstract TypeDecl DlBinaryExpr.getSemanticTypeDecl();

  protected TypeDecl DlUnionExpr.getSemanticTypeDecl() {
    return lookupType("semantics.model", "Union");
  }

  protected TypeDecl DlIntersectionExpr.getSemanticTypeDecl() {
    return lookupType("semantics.model", "Intersection");
  }

  syn nta Expr DlBinaryExpr.getTransformed() {
    return adoptToParent(
      new ClassInstanceExpr(
        getSemanticTypeDecl().createQualifiedAccess(),
        new List<Expr>(
          wrapStringInConcept(getLeftOperand()),
          wrapStringInConcept(getRightOperand())
        )
      )
    );
  }


  syn nta Expr DlQueryExpr.getTransformed() =
    adoptToParent(
      getKnowBase().mkMethodAccess(
        "query", wrapStringInConcept(getOperand())
      )
    );


  public void DlBinaryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlQueryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
