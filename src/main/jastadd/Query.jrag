aspect Query {
  eq DlEverythingExpr  .type() = lookupType("semantics.model", "Everything");
  eq DlNothingExpr     .type() = lookupType("semantics.model", "Nothing");
  eq DlUnionExpr       .type() = lookupType("semantics.model", "Union");
  eq DlIntersectionExpr.type() = lookupType("semantics.model", "Intersection");
  eq DlExistenceExpr   .type() = lookupType("semantics.model", "Existence");
  eq DlUniversalExpr   .type() = lookupType("semantics.model", "Universal");
  eq DlNegationExpr    .type() = lookupType("semantics.model", "Negation");
  eq DlInversionExpr   .type() = lookupType("semantics.model", "Inversion");
  eq DlOneExpr         .type() = lookupType("semantics.model", "One");


  eq DlLiteralExpr.isConstant() = true;

  eq DlQuantifierExpr.isConstant() =
    getLeftOperand().isConstant() && getRightOperand().isConstant();

  eq DlBinaryExpr.isConstant() =
    getLeftOperand().isConstant() && getRightOperand().isConstant();

  eq DlNegationExpr .isConstant() = getOperand().isConstant();
  eq DlInversionExpr.isConstant() = getOperand().isConstant();
  eq DlOneExpr      .isConstant() = getOperand().isConstant();


  eq DlQueryExpr.type()       = lookupType("semantics", "Individuals");
  eq DlQueryExpr.isConstant() = getOperand().isConstant();


  protected boolean Expr.isConceptOrString(Expr e) {
    TypeDecl conceptual = lookupType("semantics.model", "Conceptual");
    TypeDecl td         = e.type();
    return td.isString() || td.instanceOf(conceptual);
  }

  protected boolean Expr.isRoleOrString(Expr e) {
    TypeDecl roleish = lookupType("semantics.model", "Roleish");
    TypeDecl td      = e.type();
    return td.isString() || td.instanceOf(roleish);
  }

  protected Problem Expr.errorNotConceptOrString(Expr e) {
    return errorf("'%s' is neither concept nor string", e.type().typeName());
  }

  protected Problem Expr.errorNotRoleOrString(Expr e) {
    return errorf("'%s' is neither role nor string", e.type().typeName());
  }


  DlBinaryExpr contributes errorNotConceptOrString(getLeftOperand())
    when !isConceptOrString(getLeftOperand())
    to CompilationUnit.problems();

  DlBinaryExpr contributes errorNotConceptOrString(getRightOperand())
    when !isConceptOrString(getRightOperand())
    to CompilationUnit.problems();

  DlQuantifierExpr contributes errorNotRoleOrString(getLeftOperand())
    when !isRoleOrString(getLeftOperand())
    to CompilationUnit.problems();

  DlQuantifierExpr contributes errorNotConceptOrString(getRightOperand())
    when !isConceptOrString(getRightOperand())
    to CompilationUnit.problems();

  DlNegationExpr contributes errorNotConceptOrString(getOperand())
    when !isConceptOrString(getOperand())
    to CompilationUnit.problems();

  DlInversionExpr contributes errorNotRoleOrString(getOperand())
    when !isRoleOrString(getOperand())
    to CompilationUnit.problems();

  DlOneExpr contributes errorf("'%s' is not a string", getOperand().type().typeName())
    when !getOperand().type().isString()
    to CompilationUnit.problems();

  DlQueryExpr contributes errorNotConceptOrString(getOperand())
    when !isConceptOrString(getOperand())
    to CompilationUnit.problems();


  syn Conceptual DlBinaryExpr.setop(Conceptual c, Conceptual d);

  eq DlIntersectionExpr.setop(Conceptual c, Conceptual d) = new Intersection(c, d);
  eq DlUnionExpr       .setop(Conceptual c, Conceptual d) = new Union       (c, d);


  syn Conceptual DlQuantifierExpr.quantop(Roleish r, Conceptual c);

  eq DlExistenceExpr.quantop(Roleish r, Conceptual c) = new Existence(r, c);
  eq DlUniversalExpr.quantop(Roleish r, Conceptual c) = new Universal(r, c);


  syn Conceptual Expr.toConceptual() =
    isConstant() && type().isString() ? new Concept(constant().stringValue()) : null;

  eq DlEverythingExpr.toConceptual() = new Everything();
  eq DlNothingExpr   .toConceptual() = new Nothing();

  eq DlBinaryExpr.toConceptual() {
    Conceptual c = getLeftOperand ().toConceptual();
    Conceptual d = getRightOperand().toConceptual();
    return c == null || d == null ? null : setop(c, d);
  }

  eq DlQuantifierExpr.toConceptual() {
    Roleish    r = getLeftOperand ().toRoleish();
    Conceptual c = getRightOperand().toConceptual();
    return r == null || c == null ? null : quantop(r, c);
  }

  eq DlNegationExpr.toConceptual() {
    Conceptual c = getOperand().toConceptual();
    return c == null ? null : new Negation(c);
  }

  eq DlOneExpr.toConceptual() {
    Expr op = getOperand();
    return isConstant() && op.type().isString()
         ? new One(op.constant().stringValue())
         : null;
  }


  syn Roleish Expr.toRoleish() =
    isConstant() && type().isString() ? new Role(constant().stringValue()) : null;

  eq DlInversionExpr.toRoleish() {
    Roleish r = getOperand().toRoleish();
    return r == null ? null : new Inversion(r);
  }


  syn lazy boolean DlQueryExpr.isGuaranteedUnsatisfiable() {
    String     path = lookupKnows();
    Conceptual c    = getOperand().toConceptual();
    return path != null && c != null && !KnowBase.of(path).isSatisfiable(c);
  }

  DlQueryExpr contributes error("constant query is unsatisfiable")
    when isGuaranteedUnsatisfiable()
    to CompilationUnit.problems();
}


aspect QueryBackend {
  protected Expr Expr.mkModel(String name, Expr e) {
    if (e.type().isString()) {
      return new ClassInstanceExpr(
        lookupType("semantics.model", name).createQualifiedAccess(),
        new List<Expr>(e.treeCopyNoTransform())
      );
    }
    else {
      return e.treeCopyNoTransform();
    }
  }


  syn nta Expr DlLiteralExpr.getTransformed() =
    new ClassInstanceExpr(type().createQualifiedAccess(), new List<Expr>());

  syn nta Expr DlQuantifierExpr.getTransformed() =
    new ClassInstanceExpr(
      type().createQualifiedAccess(),
      new List<Expr>(
        mkModel("Role",    getLeftOperand()),
        mkModel("Concept", getRightOperand())
      )
    );

  syn nta Expr DlBinaryExpr.getTransformed() =
    new ClassInstanceExpr(
      type().createQualifiedAccess(),
      new List<Expr>(
        mkModel("Concept", getLeftOperand()),
        mkModel("Concept", getRightOperand())
      )
    );

  syn nta Expr DlNegationExpr.getTransformed() =
    new ClassInstanceExpr(
      type().createQualifiedAccess(),
      new List<Expr>(mkModel("Concept", getOperand()))
    );

  syn nta Expr DlInversionExpr.getTransformed() =
    new ClassInstanceExpr(
      type().createQualifiedAccess(),
      new List<Expr>(mkModel("Role", getOperand()))
    );

  syn nta Expr DlOneExpr.getTransformed() =
    mkModel("One", getOperand());

  syn nta Expr DlQueryExpr.getTransformed() =
    getKnowBase().mkMethodAccess("query", mkModel("Concept", getOperand()));


  public void DlLiteralExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlQuantifierExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlBinaryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlNegationExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlInversionExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlOneExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlQueryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
