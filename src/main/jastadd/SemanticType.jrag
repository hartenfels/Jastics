import semantics.KnowBase;
import semantics.model.Concept;
import semantics.model.Conceptual;
import semantics.model.DescriptionLogic;
import semantics.model.Everything;
import semantics.model.Existence;
import semantics.model.Intersection;
import semantics.model.Inversion;
import semantics.model.Negation;
import semantics.model.Nothing;
import semantics.model.One;
import semantics.model.Role;
import semantics.model.Roleish;
import semantics.model.Union;
import semantics.model.Universal;


aspect SemanticType {
  syn lazy Conceptual ConceptualType.toModel();
  syn lazy Roleish    RoleishType   .toModel();

  eq ParConceptualType.toModel() = getInner().toModel();
  eq ParRoleishType   .toModel() = getInner().toModel();

  eq EverythingType.toModel() = new Everything();
  eq NothingType   .toModel() = new Nothing();
  eq ConceptType   .toModel() = new Concept(getIri());
  eq OneType       .toModel() = new One(getIri());
  eq RoleType      .toModel() = new Role(getIri());

  eq NegationType .toModel() = new Negation( getOperand().toModel());
  eq InversionType.toModel() = new Inversion(getOperand().toModel());

  eq UnionType       .toModel() = new Union       (getLeft().toModel(), getRight().toModel());
  eq IntersectionType.toModel() = new Intersection(getLeft().toModel(), getRight().toModel());

  eq ExistenceType.toModel() = new Existence(getRole().toModel(), getConcept().toModel());
  eq UniversalType.toModel() = new Universal(getRole().toModel(), getConcept().toModel());


  syn nta SemanticTypeDecl ClassDecl.semanticTypeDecl(String path, Conceptual concept) {
    String escapedPath = new StringLiteral(path).escapedLiteral();

    SemanticTypeDecl decl = new SemanticTypeDecl(
      new Modifiers(),
      String.format("\"%s\".%s", escapedPath, concept),
      new Opt<Access>(new TypeAccess(packageName(), name())),
      new List<Access>(),
      new List<BodyDecl>(),
      path,
      concept
    );

    return decl;
  }


  eq SemanticTypeDecl.typeName() = getConcept().toString();
  eq SemanticTypeDecl.fullName() = getID();

  syn boolean TypeDecl.isSemanticTypeDecl() = false;
  eq  SemanticTypeDecl.isSemanticTypeDecl() = true;

  eq SemanticTypeDecl.accessibleFrom       (TypeDecl type       ) = true;
  eq SemanticTypeDecl.accessibleFromExtend (TypeDecl type       ) = true;
  eq SemanticTypeDecl.accessibleFromPackage(String   packageName) = true;


  syn TypeDecl SemanticTypeDecl.underlyingType() = ((TypeAccess) getSuperClass()).decl();

  eq SemanticTypeDecl.erasure() = underlyingType().erasure();

  eq SemanticTypeAccess.erasedCopy() = new TypeAccess("semantics.model", "Individual");


  eq SemanticTypeAccess.decl() {
    String path = lookupKnows();
    if (path != null) {
      ClassDecl ind = (ClassDecl) lookupType("semantics.model", "Individual");
      return ind.semanticTypeDecl(path, getConcept().toModel());
    }
    return unknownType();
  }

  eq SemanticTypeAccess.decls() = toSet(decl());


  eq SemanticTypeDecl.instanceOf(TypeDecl type) = type.isSupertypeOfSemanticTypeDecl(this);
  eq SemanticTypeDecl.subtype   (TypeDecl type) = type.isSupertypeOfSemanticTypeDecl(this);

  syn lazy boolean TypeDecl.isSupertypeOfSemanticTypeDecl(SemanticTypeDecl type) =
    isSupertypeOfClassDecl(type);

  eq SemanticTypeDecl.isSupertypeOfSemanticTypeDecl(SemanticTypeDecl type) {
    String path = getPath();
    if (path != null && path.equals(type.getPath())) {
      if (KnowBase.of(path).isSubtype(type.getConcept(), getConcept())) {
        return true;
      }
    }
    return super.isSupertypeOfSemanticTypeDecl(type);
  }


  syn boolean SemanticTypeDecl.sameSemanticType(SemanticTypeDecl type) =
    type.isSupertypeOfSemanticTypeDecl(this)
      && isSupertypeOfSemanticTypeDecl(type);

  eq SemanticTypeDecl.sameStructure(TypeDecl t) =
    t instanceof SemanticTypeDecl
    ? sameSemanticType((SemanticTypeDecl) t)
    : super.sameStructure(t);


  syn SemanticTypeAccess SemanticCastExpr.getSemanticTypeAccess() =
    (SemanticTypeAccess) getTypeAccess();

  syn SemanticTypeAccess SemanticInstanceOfExpr.getSemanticTypeAccess() =
    (SemanticTypeAccess) getTypeAccess();


  protected Problem SemanticType.signatureWarning(String type, String iri) {
    return warning(
        String.format("%s '%s' not in signature of '%s'", type, iri, lookupKnows()));
  }

  protected boolean SemanticType.hasSignature(String type, String iri) {
    String path = lookupKnows();
    return path != null && KnowBase.of(path).hasSignature(type, iri);
  }

  ConceptType contributes signatureWarning("concept", getIri())
    when !hasSignature("concept", getIri())
    to CompilationUnit.problems();

  RoleType contributes signatureWarning("role", getIri())
    when !hasSignature("role", getIri())
    to CompilationUnit.problems();

  OneType contributes signatureWarning("individual", getIri())
    when !hasSignature("individual", getIri())
    to CompilationUnit.problems();


  rewrite InstanceOfExpr {
    when (!(this instanceof SemanticInstanceOfExpr)
        && getTypeAccess() instanceof SemanticTypeAccess)
    to SemanticInstanceOfExpr
        new SemanticInstanceOfExpr(
          getExpr().treeCopyNoTransform(),
          getTypeAccess().treeCopyNoTransform()
        );
  }
}


aspect SemanticTypeBackend {
  eq SemanticTypeDecl.typeDescriptor() = underlyingType().typeDescriptor();

  eq SemanticTypeDecl.constantPoolName() = underlyingType().constantPoolName();

  eq SemanticTypeDecl.uniqueIndex() = underlyingType().uniqueIndex();


  protected static Expr SemanticType.cie(String cls, Expr... args) {
    return new ClassInstanceExpr(
      new TypeAccess("semantics.model", cls),
      new List<Expr>(args)
    );
  }

  syn lazy Expr SemanticType.toExpr();

  eq ParConceptualType.toExpr() = getInner().toExpr();
  eq ParRoleishType   .toExpr() = getInner().toExpr();

  eq EverythingType.toExpr() = cie("Everything");
  eq NothingType   .toExpr() = cie("Nothing");
  eq ConceptType   .toExpr() = cie("Concept", new StringLiteral(getIri()));
  eq OneType       .toExpr() = cie("One",     new StringLiteral(getIri()));
  eq RoleType      .toExpr() = cie("Role",    new StringLiteral(getIri()));

  eq NegationType .toExpr() = cie("Negation",  getOperand().toExpr());
  eq InversionType.toExpr() = cie("Inversion", getOperand().toExpr());

  eq UnionType       .toExpr() = cie("Union",        getLeft().toExpr(), getRight().toExpr());
  eq IntersectionType.toExpr() = cie("Intersection", getLeft().toExpr(), getRight().toExpr());

  eq ExistenceType.toExpr() = cie("Existence", getRole().toExpr(), getConcept().toExpr());
  eq UniversalType.toExpr() = cie("Universal", getRole().toExpr(), getConcept().toExpr());


  syn nta Expr SemanticCastExpr.getTransformed() =
    getKnowBase().mkMethodAccess(
      "cast",
      getSemanticTypeAccess().getConcept().toExpr(),
      getExpr().treeCopyNoTransform()
    );

  public void SemanticCastExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }


  syn nta Expr SemanticInstanceOfExpr.getTransformed() =
    getKnowBase().mkMethodAccess(
      "isInstanceOf",
      getSemanticTypeAccess().getConcept().toExpr(),
      getExpr().treeCopyNoTransform()
    );

  public void SemanticInstanceOfExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
