import java.util.UUID;
import semantics.KnowBase;
import semantics.model.Concept;
import semantics.model.Conceptual;
import semantics.model.Everything;
import semantics.model.Existence;
import semantics.model.Intersection;
import semantics.model.Inversion;
import semantics.model.Negation;
import semantics.model.Nothing;
import semantics.model.One;
import semantics.model.Role;
import semantics.model.Roleish;
import semantics.model.Union;
import semantics.model.Universal;


aspect SemanticTypes {
  syn lazy Conceptual ConceptualType.toModel();
  syn lazy Roleish    RoleishType   .toModel();

  eq ParConceptualType.toModel() = getInner().toModel();
  eq ParRoleishType   .toModel() = getInner().toModel();

  eq EverythingType.toModel() = new Everything();
  eq NothingType   .toModel() = new Nothing();
  eq ConceptType   .toModel() = new Concept(getIri());
  eq OneType       .toModel() = new One(getIri());
  eq RoleType      .toModel() = new Role(getIri());

  eq NegationType .toModel() = new Negation( getOperand().toModel());
  eq InversionType.toModel() = new Inversion(getOperand().toModel());

  eq UnionType       .toModel() = new Union       (getLeft().toModel(), getRight().toModel());
  eq IntersectionType.toModel() = new Intersection(getLeft().toModel(), getRight().toModel());

  eq ExistenceType.toModel() = new Existence(getRole().toModel(), getConcept().toModel());
  eq UniversalType.toModel() = new Universal(getRole().toModel(), getConcept().toModel());


  syn lazy SemanticTypeDecl ClassDecl.semanticTypeDecl(String path, Conceptual concept) {
    String escapedPath = new StringLiteral(path).escapedLiteral();

    SemanticTypeDecl decl = new SemanticTypeDecl(
      new Modifiers(),
      String.format("\"%s\".%s", escapedPath, concept),
      new Opt<Access>(new TypeAccess(packageName(), name())),
      new List<Access>(),
      new List<BodyDecl>(),
      path,
      concept
    );

    decl.setParent(getParent());
    return decl;
  }


  eq SemanticTypeDecl.typeName() = getConcept().toString();
  eq SemanticTypeDecl.fullName() = getID();

  syn boolean TypeDecl.isSemanticTypeDecl() = false;
  eq  SemanticTypeDecl.isSemanticTypeDecl() = true;

  eq SemanticTypeDecl.accessibleFrom       (TypeDecl type       ) = true;
  eq SemanticTypeDecl.accessibleFromExtend (TypeDecl type       ) = true;
  eq SemanticTypeDecl.accessibleFromPackage(String   packageName) = true;

  eq SemanticTypeDecl.erasure() = ((TypeAccess) getSuperClass()).decl().erasure();


  eq SemanticTypeAccess.decl() {
    String path = lookupKnows();
    if (path != null) {
      ClassDecl ind = (ClassDecl) lookupType("semantics.model", "Individual");
      return ind.semanticTypeDecl(path, getConcept().toModel());
    }
    return unknownType();
  }

  eq SemanticTypeAccess.decls() = toSet(decl());


  eq SemanticTypeDecl.instanceOf(TypeDecl type) = type.isSupertypeOfSemanticTypeDecl(this);

  syn lazy boolean TypeDecl.isSupertypeOfSemanticTypeDecl(SemanticTypeDecl type) =
    isSupertypeOfClassDecl(type);

  eq SemanticTypeDecl.isSupertypeOfSemanticTypeDecl(SemanticTypeDecl type) {
    String path = getPath();
    if (path != null && path.equals(type.getPath())) {
      if (KnowBase.of(path).isSubtype(type.getConcept(), getConcept())) {
        return true;
      }
    }
    return super.isSupertypeOfSemanticTypeDecl(type);
  }
}
