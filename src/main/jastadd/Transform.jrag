aspect Transform {
  protected Expr Expr.wrapStringInConcept(Expr e) {
    if (e.type().isString()) {
      return new ClassInstanceExpr(
        lookupType("semantics.model", "Concept").createQualifiedAccess(),
        new List<Expr>(e.treeCopyNoTransform())
      );
    }
    else {
      return e.treeCopyNoTransform();
    }
  }


  protected abstract TypeDecl DlBinaryExpr.getSemanticTypeDecl();

  protected TypeDecl DlUnionExpr.getSemanticTypeDecl() {
    return lookupType("semantics.model", "Union");
  }

  protected TypeDecl DlIntersectionExpr.getSemanticTypeDecl() {
    return lookupType("semantics.model", "Intersection");
  }

  syn nta Expr DlBinaryExpr.getTransformed() {
    Expr wrap = new ClassInstanceExpr(
        getSemanticTypeDecl().createQualifiedAccess(), new List<Expr>(
            wrapStringInConcept(getLeftOperand()),
            wrapStringInConcept(getRightOperand())));

    wrap.setParent(getParent());

    return wrap;
  }


  syn nta Expr DlQueryExpr.getTransformed() {
    Expr wrap = new Dot(
      new Dot(
        lookupType("semantics", "KnowBase").createQualifiedAccess(),
        new MethodAccess("of", new List<Expr>(new StringLiteral(lookupKnows())))
      ),
      new MethodAccess(
        "query", new List<Expr>(wrapStringInConcept(getOperand()))
      )
    );

    wrap.setParent(getParent());

    return wrap;
  }


  public void DlBinaryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }

  public void DlQueryExpr.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
