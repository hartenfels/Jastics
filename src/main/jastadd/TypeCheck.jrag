aspect TypeCheck {
  protected boolean Expr.isConceptOrString(Expr e) {
    TypeDecl conceptual = lookupType("semantics.model", "Conceptual");
    TypeDecl td         = e.type();
    return td.isString() || td.instanceOf(conceptual);
  }

  protected Problem Expr.errorNotConceptOrString(Expr e) {
    return errorf("'%s' is neither concept nor string", e.type().typeName());
  }


  DlBinaryExpr contributes errorNotConceptOrString(getLeftOperand())
    when !isConceptOrString(getLeftOperand())
    to CompilationUnit.problems();

  DlBinaryExpr contributes errorNotConceptOrString(getRightOperand())
    when !isConceptOrString(getRightOperand())
    to CompilationUnit.problems();


  DlQueryExpr contributes error("class 'knows' no data source for querying")
    when lookupKnows() == null
    to CompilationUnit.problems();

  DlQueryExpr contributes errorNotConceptOrString(getOperand())
    when !isConceptOrString(getOperand())
    to CompilationUnit.problems();


  protected boolean Stmt.isIndividual(Expr e) {
    return e.type().instanceOf(lookupType("semantics.model", "Individual"));
  }

  protected Problem Stmt.errorNotIndividual(Expr e) {
    return errorf("'%s' is not an individual", e.type().typeName());
  }


  DlTypecaseStmt contributes error("class 'knows' no data source for typecasing")
    when lookupKnows() == null
    to CompilationUnit.problems();

  DlTypecaseStmt contributes errorNotIndividual(getExpr())
    when !isIndividual(getExpr())
    to CompilationUnit.problems();
}
