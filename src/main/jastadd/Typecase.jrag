import semantics.KnowBase;


aspect Typecase {
  syn lazy VariableDeclarator DlTypecaseish.caseVar();

  eq DlTypecase       .caseVar() = VarDeclStmt().getDeclarator(0);
  eq DlTypecaseDefault.caseVar() = null;

  syn nta VarDeclStmt DlTypecase.VarDeclStmt() =
    new VarDeclStmt(
      new Modifiers(new List<Modifier>(new Modifier("final"))),
      new SemanticTypeAccess("semantics.model", "Individual", type()),
      new List<VariableDeclarator>(
        new VariableDeclarator(
          getIdent(),
          new List<Dims>(),
          new Opt<Expr>(new NullLiteral("null"))
        )
      )
    );


  eq DlTypecaseStmt.getCases(int i).lookupVariable(String name) {
    VariableDeclarator var = getCases(i).caseVar();
    return var != null && var.getID().equals(name) ? var : lookupVariable(name);
  }


  eq DlTypecaseStmt.getCases(int i).assignedBefore(Variable v) =
    v == getCases(i).caseVar() || assignedBefore(v);


  eq DlTypecaseStmt.modifiedInScope(Variable var) {
    for (DlTypecaseish c : getCasesList()) {
      if (c.modifiedInScope(var)) {
        return true;
      }
    }
    return false;
  }

  syn boolean DlTypecaseish.modifiedInScope(Variable var) = getBlock().modifiedInScope(var);


  syn boolean DlTypecaseish.isDefaultCase();

  eq DlTypecase       .isDefaultCase() = false;
  eq DlTypecaseDefault.isDefaultCase() = true;


  syn ConceptualType DlTypecaseish.type();

  eq DlTypecase       .type() = getType();
  eq DlTypecaseDefault.type() = null;


  protected boolean DlTypecaseStmt.isIndividual(Expr e) {
    return e.type().instanceOf(lookupType("semantics.model", "Individual"));
  }

  protected Problem DlTypecaseStmt.errorNotIndividual(Expr e) {
    return errorf("'%s' is not an individual", e.type().typeName());
  }

  DlTypecaseStmt contributes errorNotIndividual(getExpr())
    when !isIndividual(getExpr())
    to CompilationUnit.problems();


  DlTypecaseStmt contributes each caseProblems() to CompilationUnit.problems();

  syn Collection<Problem> DlTypecaseStmt.caseProblems() {
    Collection<Problem> problems  = new LinkedList<Problem>();
    int                 defaults  = 0;

    for (DlTypecaseish c : getCasesList()) {
      if (c.isDefaultCase()) {
        ++defaults;
      }
    }

    if (defaults != 1) {
      problems.add(errorf("typecase has %d defaults, should be exactly 1", defaults));
    }
    else if (!getCases(getNumCases() - 1).isDefaultCase()) {
      problems.add(error("default must be the last block in typecase"));
    }

    return problems;
  }


  public java.util.List<DlTypecaseish> DlTypecaseStmt.getTypecases() {
    java.util.List<DlTypecaseish> cases = new LinkedList<DlTypecaseish>();

    for (DlTypecaseish c : getCasesList()) {
      if (!c.isDefaultCase()) {
        cases.add(c);
      }
    }

    return cases;
  }

  DlTypecaseStmt contributes each subsumationProblems() to CompilationUnit.problems();

  syn Collection<Problem> DlTypecaseStmt.subsumationProblems() {
    Collection<Problem>           problems = new LinkedList<Problem>();
    java.util.List<DlTypecaseish> cases    = getTypecases();
    String                        knows    = lookupKnows();

    if (!cases.isEmpty() && knows != null) {
      KnowBase       kb   = KnowBase.of(knows);
      Everything     top  = new Everything();
      ConceptualType prev = null;
      Conceptual     pm   = null;

      for (DlTypecaseish c : cases) {
        ConceptualType cur = c.type();
        Conceptual     cm  = cur.toModel();

        if (pm != null && kb.isSubtype(cm, pm)) {
          String pprev = prev.prettyPrint();
          String pcur  = cur .prettyPrint();
          problems.add(errorf("bad typecase order, '%s' subsumes '%s'", pprev, pcur));
        }

        if (!kb.isSatisfiable(cm)) {
          String pcur = cur.prettyPrint();
          problems.add(errorf(
              "typecase '%s' is unsatisfiable and will never match", pcur));
        }
        else if (kb.isSubtype(top, cm)) {
          String pcur = cur.prettyPrint();
          problems.add(errorf(
              "typecase '%s' will always match, use the default case instead", pcur));
        }

        prev = cur;
        pm   = cm;
      }
    }

    return problems;
  }
}


aspect TypecaseBackend {
  public static VarDeclStmt DlTypecaseStmt.mkVarDecl(String pkg, String cls,
                                                     String name, Expr init) {
    return new VarDeclStmt(
      new Modifiers(new List<Modifier>(new Modifier("final"))),
      new TypeAccess(pkg, cls),
      new List<VariableDeclarator>(
        new VariableDeclarator(name, new List<Dims>(), new Opt<Expr>(init))
      )
    );
  }

  protected Expr DlTypecaseStmt.mkKnowBaseExpr() {
    return new Dot(
      lookupType("semantics", "KnowBase").createQualifiedAccess(),
      new MethodAccess("of", new List<Expr>(new StringLiteral(lookupKnows())))
    );
  }


  syn Stmt DlTypecaseish.getTransformed();

  eq DlTypecaseDefault.getTransformed() = getBlock().treeCopyNoTransform();

  eq DlTypecase.getTransformed() {
    VarDeclStmt vd = VarDeclStmt().treeCopyNoTransform();
    vd.getDeclarator(0).setInit(new VarAccess("#topic"));
    return new Block(new List<Stmt>(vd, getBlock().treeCopyNoTransform()));
  }


  protected Stmt DlTypecaseStmt.getTransformedCases() {
      IfStmt first = null, prev = null;

      for (DlTypecaseish c : getCasesList()) {
        if (c.isDefaultCase()) {
          prev.setElse(c.getTransformed());
        }
        else {
          IfStmt cond = new IfStmt(
            new Dot(
              new VarAccess("#kb"),
              new MethodAccess(
                "isMember",
                new List<Expr>(c.type().toExpr(), new VarAccess("#topic"))
              )
            ),
            c.getTransformed()
          );

          if (prev == null) {
            first = cond;
          }
          else {
            prev.setElse(cond);
          }

          prev = cond;
        }
      }

      return first;
  }


  syn nta Stmt DlTypecaseStmt.getTransformed() {
    List<Stmt> stmts = new List<>();

    if (getNumCases() == 1) {
      stmts.add(getCases(0).getTransformed());
    }
    else {
      stmts.add(mkVarDecl("semantics.model", "Individual", "#topic",
                          getExpr().treeCopyNoTransform()));
      stmts.add(mkVarDecl("semantics", "KnowBase", "#kb", mkKnowBaseExpr()));
      stmts.add(getTransformedCases());
    }

    return new Block(stmts);
  }


  public void DlTypecaseStmt.createBCode(CodeGeneration gen) {
    getTransformed().createBCode(gen);
  }
}
