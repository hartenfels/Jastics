import semantics.KnowBase;


aspect Typecase {
  syn lazy VariableDeclarator DlTypecaseish.caseVar();

  eq DlTypecase       .caseVar() = VarDeclStmt().getDeclarator(0);
  eq DlTypecaseDefault.caseVar() = null;

  syn nta VarDeclStmt DlTypecase.VarDeclStmt() =
    new VarDeclStmt(
      new Modifiers(new List<Modifier>(new Modifier("final"))),
      new TypeAccess("semantics.model", "Individual"),
      new List<VariableDeclarator>(
        new VariableDeclarator(
          getIdent(),
          new List<Dims>(),
          new Opt<Expr>(new NullLiteral("null"))
        )
      )
    );


  eq DlTypecaseStmt.getCases(int i).lookupVariable(String name) {
    VariableDeclarator var = getCases(i).caseVar();
    return var != null && var.getID().equals(name) ? var : lookupVariable(name);
  }


  eq DlTypecaseStmt.getCases(int i).assignedBefore(Variable v) {
    return v == getCases(i).caseVar() || assignedBefore(v);
  }


  eq DlTypecaseStmt.modifiedInScope(Variable var) {
    for (DlTypecaseish c : getCasesList()) {
      if (c.modifiedInScope(var)) {
        return true;
      }
    }
    return false;
  }

  syn boolean DlTypecaseish.modifiedInScope(Variable var) = getBlock().modifiedInScope(var);


  syn boolean DlTypecaseish.isDefaultCase();

  eq DlTypecase       .isDefaultCase() = false;
  eq DlTypecaseDefault.isDefaultCase() = true;


  syn ConceptualType DlTypecaseish.type();

  eq DlTypecase       .type() = getType();
  eq DlTypecaseDefault.type() = null;


  DlTypecaseStmt contributes each caseProblems() to CompilationUnit.problems();

  syn Collection<Problem> DlTypecaseStmt.caseProblems() {
    Collection<Problem> problems  = new LinkedList<Problem>();
    int                 defaults  = 0;

    for (DlTypecaseish c : getCasesList()) {
      if (c.isDefaultCase()) {
        ++defaults;
      }
    }

    if (defaults != 1) {
      problems.add(errorf("typecase has %d defaults, should be exactly 1", defaults));
    }
    else if (!getCases(getNumCases() - 1).isDefaultCase()) {
      problems.add(error("default must be the last block in typecase"));
    }

    return problems;
  }


  public java.util.List<DlTypecaseish> DlTypecaseStmt.getTypecases() {
    java.util.List<DlTypecaseish> cases = new LinkedList<DlTypecaseish>();

    for (DlTypecaseish c : getCasesList()) {
      if (!c.isDefaultCase()) {
        cases.add(c);
      }
    }

    return cases;
  }

  DlTypecaseStmt contributes each subsumationProblems() to CompilationUnit.problems();

  syn Collection<Problem> DlTypecaseStmt.subsumationProblems() {
    Collection<Problem>           problems = new LinkedList<Problem>();
    java.util.List<DlTypecaseish> cases    = getTypecases();
    String                        knows    = lookupKnows();

    if (!cases.isEmpty() && knows != null) {
      KnowBase       kb   = KnowBase.of(knows);
      Everything     top  = new Everything();
      ConceptualType prev = null;
      Conceptual     pm   = null;

      for (DlTypecaseish c : cases) {
        ConceptualType cur = c.type();
        Conceptual     cm  = cur.toModel();

        if (pm != null && kb.isSubtype(cm, pm)) {
          String pprev = prev.prettyPrint();
          String pcur  = cur .prettyPrint();
          problems.add(errorf("bad typecase order, '%s' subsumes '%s'", pprev, pcur));
        }

        if (!kb.isSatisfiable(cm)) {
          String pcur = cur.prettyPrint();
          problems.add(errorf(
              "typecase '%s' is unsatisfiable and will never match", pcur));
        }
        else if (kb.isSubtype(top, cm)) {
          String pcur = cur.prettyPrint();
          problems.add(errorf(
              "typecase '%s' will always match, use the default case instead", pcur));
        }

        prev = cur;
        pm   = cm;
      }
    }

    return problems;
  }
}
