Expr dl_union_expression =
    dl_union_expression.e1 DL_UNION dl_intersection_expression.e2
        {: return new DlUnionExpr(e1, e2); :}
  | dl_intersection_expression @BOTTOM
  ;

Expr dl_union_expression_nn =
    dl_union_expression_nn.e1 DL_UNION dl_intersection_expression_nn.e2
        {: return new DlUnionExpr(e1, e2); :}
  | dl_intersection_expression_nn
  ;


Expr dl_intersection_expression =
    dl_intersection_expression.e1 DL_INTERSECTION dl_quantifier_expression.e2
        {: return new DlIntersectionExpr(e1, e2); :}
  | dl_quantifier_expression @BOTTOM
  ;

Expr dl_intersection_expression_nn =
    dl_intersection_expression_nn.e1 DL_INTERSECTION dl_quantifier_expression_nn.e2
        {: return new DlIntersectionExpr(e1, e2); :}
  | dl_quantifier_expression_nn
  ;


Expr dl_quantifier_expression =
    DL_EXISTENCE expression.e1 DL_ARROW expression.e2
        {: return new DlExistenceExpr(e1, e2); :}
  | DL_UNIVERSAL expression.e1 DL_ARROW expression.e2
        {: return new DlUniversalExpr(e1, e2); :}
  | shift_expression @BOTTOM
  ;

Expr dl_quantifier_expression_nn =
    DL_EXISTENCE expression_nn.e1 DL_ARROW expression.e2
        {: return new DlExistenceExpr(e1, e2); :}
  | DL_UNIVERSAL expression_nn.e1 DL_ARROW expression.e2
        {: return new DlUniversalExpr(e1, e2); :}
  | shift_expression_nn
  ;


Expr dl_postfix_expression =
    dl_query      @BOTTOM
  | dl_inversion_expression
  ;

Expr postfix_expression    = dl_postfix_expression;
Expr postfix_expression_nn = dl_postfix_expression;


Expr dl_unary_expression =
    dl_negation_expression
  | dl_one_expression
  ;

Expr unary_expression_not_plus_minus    = dl_unary_expression;
Expr unary_expression_not_plus_minus_nn = dl_unary_expression;


Expr dl_negation_expression =
    DL_NEGATION expression.e {: return new DlNegationExpr(e); :}
  ;

Expr dl_inversion_expression =
    postfix_expression.e DL_INVERSION @POSTINCDEC {: return new DlInversionExpr(e); :}
  ;


Expr dl_one_expression =
    DL_LCURLY expression.e DL_RCURLY {: return new DlOneExpr(e); :}
  ;


Expr literal =
    DL_EVERYTHING {: return new DlEverythingExpr(DL_EVERYTHING); :}
  | DL_NOTHING    {: return new DlNothingExpr   (DL_NOTHING   ); :}
  ;


// Ideally, we'd just call our keyword `query`, but that's such a common method
// name that it would break huge amounts of Java code. So instead, we take
// Java's `do` keyword out of context and turn our construct into
// `do-query(...)`. The `do` is invalid as an expression, so it doesn't cause
// any conflicts. The `query` is just an identifier, and we manually throw a
// syntax error if it's not the string "query". The minus in between the two
// could also be whitespace, but it looks more like a single term this way.

Expr dl_query =
    DO MINUS IDENTIFIER LPAREN expression.e RPAREN {:
        if (!IDENTIFIER.value.equals("query")) {
          report.syntaxError(IDENTIFIER);
        }
        return new DlQueryExpr(e);
      :}
  ;
